<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.68.3"><title>Homepage | Rune Nielsen</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Rune Nielsen"><meta property="article:published_time" content="17-07-2017 00:00:00"><link async href="https://fonts.googleapis.com/css2?family=Jura:wght@300;400;500;600;700&display=swap" rel=stylesheet><link async rel=stylesheet href=/css/main.css type=text/css><link async rel=icon href=/favicon.ico><script async src=https://kit.fontawesome.com/0d71694d01.js crossorigin=anonymous></script></head><body><div class=grid-container><header class=header><div class=header-collection><div class=header-item><a class=header-item__link href=/><h1 class=header-item__title>Homepage | Rune Nielsen</h1></a></div></div><div class=header-collection><div class=header-item><a class=header-item__link target=_blank href=https://github.com/runeanielsen><p class=header-item__icon><i class="fab fa-github-square"></i></p></a></div><div class=header-item><a class=header-item__link target=_blank href=https://linkedin.com/in/runeanielsen><p class=header-item__icon><i class="fab fa-linkedin"></i></p></a></div></div></header><main class=main><a class=post__link href=https://runenielsen.com/posts/javascript-closure/><article class=post><h2 class=post__title>JavaScript closure</h2><p class=post__description>In JavaScript when a function is nested inside of another function, the inner function has access to the outer function scope. The innermost function has access to all the parent scopes and therefore has closure over all of them. Because the inner function has closure over the parent functions, it is able to use the variables, even when the function has returned.</p><p class=post__date>Mon, May 8, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/javascript-lexical-scope/><article class=post><h2 class=post__title>JavaScript lexical scope</h2><p class=post__description>In this blog post, I will explain how the lexical scoping model is defined and how it is being used in JavaScript. I will go over how the lexical scope differs from the dynamic scoping model by using the example of the how the execution of a JavaScript program would look like if it was using the dynamic scoping model and after that showing how it is done in JavaScript using the lexical scoping model.</p><p class=post__date>Mon, May 1, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/javascript-understanding-scope/><article class=post><h2 class=post__title>JavaScript understanding scope</h2><p class=post__description>To efficiently program in javascript you will have to understand the principle of scope. The javascript scope is the set of variables you have access to, this goes for both objects and functions since in javascript functions and objects are also variables. To better understand scope we will have to look into how javascript is being executed. By taking a look at the compiler, engine and the scope.</p><p class=post__date>Fri, Apr 14, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/ioc-container-service-lifetimes-in-aspnetcore/><article class=post><h2 class=post__title>IOC Container Service Lifetimes in ASP.NET Core</h2><p class=post__description>When you're building a web application it is important to be able to control the service lifetime of the registrations in your container. The reason is that some of your objects might require being instantiated on every request while another instance should be unique and should only be instantiated once in the application lifespan.</p><p class=post__date>Sat, Apr 1, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/hoisting-in-javascript/><article class=post><h2 class=post__title>Hoisting in JavaScript</h2><p class=post__description>In JavaScript, a variable can be declared after it has been used. In other words, a variable can be used before it has been declared, this is called hoisting. The term hoisting cannot be found in the official JavaScript documents, but the term was invented as a general way of thinking about what happens in the compilation phase when variables and function declarations are moved to the top of their containing scope. To be exact the variables are not being moved to the top of the scope, but they're being stored in memory doing the compile phase, so they can be used in the execution phase.</p><p class=post__date>Thu, Mar 23, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/what-is-this-in-javascript/><article class=post><h2 class=post__title>What is 'this' in JavaScript</h2><p class=post__description>In a language like C# 'this' always points to the containing class, so going into JavaScript you might think that 'this' always points to the containing function, but this is not the case. Sometimes you will find 'this' actually pointing to the function, but other times you will find it pointing to the global object or to something third. In this post, I will go through the rules of how the 'this' binding is being set, so hopefully, development in JavaScript using the 'this' keyword will get easier and less confusing.</p><p class=post__date>Thu, Mar 23, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/webpack-2-handling-sass/><article class=post><h2 class=post__title>Webpack 2 handling Sass</h2><p class=post__description>A lot of developers today write their styles in a transpiled language like Sass or Less. Creating a setup is needed to transpile, bundle and minify the code. In this post I will show you how to setup a build flow with Webpack 2, to transpile, bundle, minify and add vendor specific CSS to the final bundle.</p><p class=post__date>Sat, Mar 4, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/webpack-2-bundling-using-babel/><article class=post><h2 class=post__title>Webpack 2 bundling using Babel</h2><p class=post__description>Browser compatibility can be a pain and make you not use the new features of JavaScript ES6 and beyond. Luckily there is a savior, Babel. Babel is a way to transpile ES6+ JavaScript code to your version of choice. In this post I will show you have to setup Babel using Webpack 2 to transpile ES6 to ES5 JavaScript.</p><p class=post__date>Sun, Feb 5, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/webpack-2-bundling-javascript/><article class=post><h2 class=post__title>Webpack 2 bundling JavaScript</h2><p class=post__description>JavaScript heavy websites are becoming more and more common. To reduce the number of HTTP requests and solve the problems with which order scripts should be loaded, tools like Webpack has emerged. In this post, I will show you how to setup Webpack 2 and use it to bundle JavaScript files. To follow the guide you should have node package manager installed and have a basic understanding of modules in JavaScript.</p><p class=post__date>Mon, Jan 30, 2017</p></article></a><a class=post__link href=https://runenielsen.com/posts/response-caching-in-aspnetcore/><article class=post><h2 class=post__title>Response Caching in ASP.NET Core</h2><p class=post__description>Using caching is an essential way to improve performance in your application. With ASP.NET Core you have to download and setup the associated middlewares. In this blog post, I will introduce you to response caching and show how to implement it in a web application.</p><p class=post__date>Tue, Jan 17, 2017</p></article></a><div class=pagination><div class=pagination-container><a class=pagination-action href=/>&lt;-</a><div class=pagination-indicator>2/3</div><a class=pagination-action href=/page/3/>-></a></div></div></main></div></body></html>